# Frontend v1.2.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver the v1.2.0 Config-First UX Refresh: dark mode, log tab, actionable Updates tab, and improved config workflow — all in vanilla JS/CSS with no build process.

**Architecture:** CSS custom properties handle theming (light/dark) via a `[data-theme]` attribute on `<html>`. HTML structure gains a 4th Log tab. Backend gets one new POST endpoint for manual update application. All JS changes extend the existing global patterns in `app.js`.

**Tech Stack:** Vanilla JS (ES2017+), CSS custom properties, Flask + Socket.IO (backend), pytest (backend tests)

---

## Task 1: HTML Structure — Log Tab + Controls Cleanup

**Files:**
- Modify: `templates/index.html`

This is a pure HTML edit. No test needed; verify visually.

**Step 1: Add the Log tab button to the tab strip**

In `templates/index.html`, find the `<div class="tabs">` block (lines 36–40). Add a Log tab button after the History button:

```html
<div class="tabs">
    <button class="tab-button active" data-tab="updates">Updates</button>
    <button class="tab-button" data-tab="config">Configuration</button>
    <button class="tab-button" data-tab="history">History</button>
    <button class="tab-button" data-tab="log">Log <span id="log-badge" class="tab-badge" style="display:none"></span></button>
</div>
```

**Step 2: Add the Log tab pane (with the log output inside)**

Inside `<div class="tab-content">`, add a new pane after the `#history` pane:

```html
<div id="log" class="tab-pane">
    <h2>Activity Log</h2>
    <div id="log-output" class="log-output" style="height: 400px;"></div>
</div>
```

**Step 3: Remove the old always-visible log section**

Delete the entire block (lines 127–130):

```html
<div class="log-section">
    <h3>Activity Log</h3>
    <div id="log-output" class="log-output"></div>
</div>
```

**Step 4: Remove the Refresh Config button from the controls bar**

In the `<div class="controls">` block (line 26–34), delete:

```html
<button id="refresh-config" class="btn btn-secondary">Refresh Config</button>
```

**Step 5: Add theme toggle button to the header status bar**

Inside `<div class="status-bar">`, add after the last `<span>`:

```html
<button id="theme-toggle" class="btn-icon btn-theme-toggle" title="Toggle dark/light mode" aria-label="Toggle theme">◑</button>
```

**Step 6: Add unsaved-changes banner above the config pane content**

Inside `<div id="config" class="tab-pane">`, add before `<h2>Configuration</h2>`:

```html
<div id="unsaved-banner" class="unsaved-banner" style="display:none">
    You have unsaved changes &mdash;
    <button class="btn btn-sm btn-primary" onclick="saveConfig()">Save Now</button>
</div>
```

**Step 7: Verify the HTML renders**

Open the UI in a browser. Confirm:
- 4 tabs visible: Updates, Configuration, History, Log
- Activity Log content appears in the Log tab
- No duplicate `#log-output` in the DOM (check DevTools)
- Refresh Config button is gone from controls bar
- `◑` toggle button appears in the status bar

**Step 8: Commit**

```bash
git add templates/index.html
git commit -m "feat(ui): add log tab, theme toggle button, unsaved banner skeleton"
```

---

## Task 2: CSS — Dark Mode Variables + Toggle Styles

**Files:**
- Modify: `static/css/style.css`

**Step 1: Add dark mode variable overrides at the end of `:root` section**

After the closing `}` of the `:root` block (line 11), add:

```css
[data-theme="dark"] {
    --primary-color: #42a5f5;
    --success-color: #66bb6a;
    --warning-color: #ffa726;
    --danger-color: #ef5350;
    --background: #121212;
    --surface: #1e1e1e;
    --text-primary: #e0e0e0;
    --text-secondary: #9e9e9e;
    --border: #333333;
}
```

**Step 2: Make the log output adapt to dark mode**

The log output is currently hardcoded `background: #1e1e1e`. In dark mode, distinguish it from the page surface. Add after the `[data-theme="dark"]` block:

```css
[data-theme="dark"] .log-output {
    background: #0d0d0d;
    border: 1px solid var(--border);
}
```

**Step 3: Style the theme toggle button**

Add after the `.btn-delete:hover` rule:

```css
.btn-theme-toggle {
    font-size: 18px;
    margin-left: auto;
}

.btn-theme-toggle:hover {
    background: var(--border);
}
```

**Step 4: Style the tab badge**

Add near the `.badge` rules:

```css
.tab-badge {
    display: inline-block;
    background: var(--danger-color);
    color: white;
    border-radius: 10px;
    font-size: 11px;
    font-weight: bold;
    padding: 1px 6px;
    margin-left: 4px;
    vertical-align: middle;
}
```

**Step 5: Verify**

Load the UI. Temporarily add `data-theme="dark"` to `<html>` in DevTools. Confirm:
- Background becomes `#121212`
- Surface cards become `#1e1e1e`
- Text is readable
- Blue buttons shift to the lighter `#42a5f5`

Remove the temporary attribute when done.

**Step 6: Commit**

```bash
git add static/css/style.css
git commit -m "feat(ui): add dark mode CSS variables and tab badge styles"
```

---

## Task 3: CSS — Toast, Unsaved Banner, Apply Button, Empty State

**Files:**
- Modify: `static/css/style.css`

**Step 1: Add toast notification styles**

Add at the end of `style.css`:

```css
/* ── Toast Notifications ─────────────────────────────────────────────────── */
.toast-container {
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    gap: 8px;
    pointer-events: none;
}

.toast {
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: white;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.25s ease, transform 0.25s ease;
    pointer-events: auto;
}

.toast.toast-show {
    opacity: 1;
    transform: translateY(0);
}

.toast.toast-success { background: var(--success-color); }
.toast.toast-error   { background: var(--danger-color); }
.toast.toast-info    { background: var(--primary-color); }
```

**Step 2: Add unsaved-changes banner styles**

```css
/* ── Unsaved Changes Banner ──────────────────────────────────────────────── */
.unsaved-banner {
    background: #fff3cd;
    border: 1px solid #ffc107;
    color: #856404;
    padding: 10px 16px;
    border-radius: 6px;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 14px;
}

[data-theme="dark"] .unsaved-banner {
    background: #3d2e00;
    border-color: #ffa726;
    color: #ffd54f;
}
```

**Step 3: Add Apply Update button styles**

```css
/* ── Apply Update Button ─────────────────────────────────────────────────── */
.btn-apply {
    background-color: var(--primary-color);
    color: white;
    min-width: 110px;
}

.btn-apply:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}

.btn-apply.applied {
    background-color: var(--success-color);
    cursor: default;
}

.update-item.applied {
    border-left-color: var(--success-color);
    opacity: 0.8;
}

.update-error {
    color: var(--danger-color);
    font-size: 13px;
    margin-top: 6px;
}
```

**Step 4: Richer update card layout**

```css
.update-item-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 12px;
    flex-wrap: wrap;
}
```

**Step 5: Empty state for config tab**

```css
/* ── Config Empty State ──────────────────────────────────────────────────── */
.config-empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-secondary);
}

.config-empty-state p {
    margin-bottom: 20px;
    font-size: 15px;
}

.config-empty-state .empty-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
}
```

**Step 6: Verify visually**

Open DevTools and manually inject a toast div / unsaved banner into the DOM to confirm styling looks correct in both light and dark modes.

**Step 7: Commit**

```bash
git add static/css/style.css
git commit -m "feat(ui): add toast, unsaved banner, apply button, and empty state styles"
```

---

## Task 4: JS — Dark Mode Toggle Logic

**Files:**
- Modify: `static/js/app.js`

**Step 1: Add the theme management functions near the top of `app.js` (after the global state block)**

Add after `let isDaemonRunning = false;`:

```javascript
// ── Theme management ─────────────────────────────────────────────────────
const THEME_KEY = 'ium-theme'; // values: 'light', 'dark', 'system'

function getSystemPrefersDark() {
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
}

function applyTheme(preference) {
    // preference: 'light' | 'dark' | 'system'
    const isDark = preference === 'dark' || (preference === 'system' && getSystemPrefersDark());
    document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
}

function initTheme() {
    const saved = localStorage.getItem(THEME_KEY) || 'system';
    applyTheme(saved);

    // Listen for OS preference changes when in system mode
    if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            const current = localStorage.getItem(THEME_KEY) || 'system';
            if (current === 'system') applyTheme('system');
        });
    }
}

function cycleTheme() {
    // Cycle: system → light → dark → system
    const current = localStorage.getItem(THEME_KEY) || 'system';
    const next = current === 'system' ? 'light' : current === 'light' ? 'dark' : 'system';
    localStorage.setItem(THEME_KEY, next);
    applyTheme(next);
    updateThemeToggleLabel(next);
}

function updateThemeToggleLabel(preference) {
    const btn = document.getElementById('theme-toggle');
    if (!btn) return;
    const labels = { system: '◑', light: '☀', dark: '☽' };
    btn.textContent = labels[preference] || '◑';
    btn.title = `Theme: ${preference} — click to change`;
}
```

**Step 2: Call `initTheme()` at the very start of `DOMContentLoaded`**

In the `document.addEventListener('DOMContentLoaded', () => {` block, add as the very first line:

```javascript
initTheme();
updateThemeToggleLabel(localStorage.getItem(THEME_KEY) || 'system');
```

**Step 3: Wire up the toggle button in `DOMContentLoaded`**

After the `dom.appVersion` assignment, add:

```javascript
document.getElementById('theme-toggle').addEventListener('click', cycleTheme);
```

**Step 4: Verify**

1. Load the UI — it should respect your OS dark/light preference automatically
2. Click `◑` — it should cycle to ☀ (light), then ☽ (dark), then back to ◑ (system)
3. Reload — it should remember the chosen theme
4. Check in both modes that the UI looks correct

**Step 5: Commit**

```bash
git add static/js/app.js
git commit -m "feat(ui): add dark mode toggle with system preference and localStorage"
```

---

## Task 5: JS — Log Tab + Unread Badge

**Files:**
- Modify: `static/js/app.js`

**Step 1: Add log badge tracking state (after the `isDaemonRunning` global)**

```javascript
let logUnreadCount = 0;
let activeTab = 'updates'; // track current tab
```

**Step 2: Update the `switchTab` function to reset the log badge when Log tab is opened**

Replace the existing `switchTab` function:

```javascript
function switchTab(tabName) {
    activeTab = tabName;

    document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tab === tabName) btn.classList.add('active');
    });

    document.querySelectorAll('.tab-pane').forEach(pane => {
        pane.classList.remove('active');
        if (pane.id === tabName) pane.classList.add('active');
    });

    if (tabName === 'log') {
        logUnreadCount = 0;
        updateLogBadge();
        // Scroll to bottom when opening
        if (dom.logOutput) {
            dom.logOutput.scrollTop = dom.logOutput.scrollHeight;
        }
    }
}
```

**Step 3: Add the `updateLogBadge` helper**

Add after `switchTab`:

```javascript
function updateLogBadge() {
    const badge = document.getElementById('log-badge');
    if (!badge) return;
    if (logUnreadCount > 0) {
        badge.textContent = logUnreadCount > 99 ? '99+' : logUnreadCount;
        badge.style.display = '';
    } else {
        badge.style.display = 'none';
    }
}
```

**Step 4: Update `addLog` to increment the badge when Log tab is not active**

In the existing `addLog` function, add before `dom.logOutput.scrollTop = dom.logOutput.scrollHeight;`:

```javascript
if (activeTab !== 'log') {
    logUnreadCount++;
    updateLogBadge();
}
```

**Step 5: Cache `dom.logBadge` in `DOMContentLoaded`** (optional but consistent with pattern)

The badge is already being fetched by ID inline; this is fine since `updateLogBadge` does `getElementById` each time. No change needed here.

**Step 6: Remove the now-dead `refresh-config` event listener**

Find and delete this line from `DOMContentLoaded`:

```javascript
document.getElementById('refresh-config').addEventListener('click', loadConfig);
```

**Step 7: Verify**

1. Click "Check Now" — watch log lines appear in the Log tab
2. Switch to Updates tab, then trigger a check — confirm the Log badge shows a number
3. Click the Log tab — badge disappears
4. Confirm log scrolls to bottom when Log tab is opened

**Step 8: Commit**

```bash
git add static/js/app.js
git commit -m "feat(ui): move log to tab with unread badge counter"
```

---

## Task 6: Backend — `POST /api/apply-update` Endpoint (TDD)

**Files:**
- Modify: `webui.py`
- Modify: `tests/test_webui.py`

**Step 1: Write the failing tests**

In `tests/test_webui.py`, find the section after the existing POST endpoint tests and add:

```python
# ---------------------------------------------------------------------------
# POST /api/apply-update
# ---------------------------------------------------------------------------

class TestApplyUpdate:
    """Tests for the manual apply-update endpoint."""

    def test_apply_update_missing_fields(self, client):
        """Returns 400 when required fields are missing."""
        resp = _post_json(client, '/api/apply-update', {})
        assert resp.status_code == 400
        assert 'error' in resp.get_json()

    def test_apply_update_image_not_in_last_updates(self, client):
        """Returns 404 when no pending update exists for the image."""
        resp = _post_json(client, '/api/apply-update', {
            'image': 'nonexistent/image',
            'new_tag': '1.0.0'
        })
        assert resp.status_code == 404
        assert 'error' in resp.get_json()

    def test_apply_update_success(self, client, monkeypatch):
        """Returns 200 and applies the update when a valid update is pending."""
        import webui as webui_mod

        # Seed a pending update into last_updates
        monkeypatch.setattr(webui_mod, 'last_updates', [{
            'image': 'nginx',
            'base_tag': 'latest',
            'old_tag': '1.26.0',
            'new_tag': '1.27.0',
            'digest': 'sha256:abc123',
            'auto_update': False
        }])

        # Mock the updater methods to avoid real Docker calls
        mock_pull = MagicMock(return_value=True)
        mock_get_containers = MagicMock(return_value=[{'name': 'my-nginx'}])
        mock_update_containers = MagicMock(return_value={'my-nginx': True})
        mock_get_config = MagicMock(return_value={
            'image': 'nginx',
            'regex': r'^[0-9]+\.[0-9]+\.[0-9]+$',
            'base_tag': 'latest',
            'registry': None,
            'cleanup_old_images': False,
            'keep_versions': 3
        })

        monkeypatch.setattr(webui_mod.updater, '_pull_image', mock_pull)
        monkeypatch.setattr(webui_mod.updater, '_get_containers_for_image', mock_get_containers)
        monkeypatch.setattr(webui_mod.updater, '_update_containers', mock_update_containers)

        resp = _post_json(client, '/api/apply-update', {
            'image': 'nginx',
            'new_tag': '1.27.0'
        })
        assert resp.status_code == 200
        data = resp.get_json()
        assert data['success'] is True
        mock_pull.assert_called()
        mock_update_containers.assert_called_once_with(['my-nginx'], 'nginx', '1.27.0', None)

    def test_apply_update_pull_failure(self, client, monkeypatch):
        """Returns 500 when image pull fails."""
        import webui as webui_mod

        monkeypatch.setattr(webui_mod, 'last_updates', [{
            'image': 'nginx', 'base_tag': 'latest',
            'old_tag': '1.26.0', 'new_tag': '1.27.0',
            'digest': 'sha256:abc', 'auto_update': False
        }])
        monkeypatch.setattr(webui_mod.updater, '_pull_image', MagicMock(return_value=False))

        resp = _post_json(client, '/api/apply-update', {
            'image': 'nginx', 'new_tag': '1.27.0'
        })
        assert resp.status_code == 500
        assert 'error' in resp.get_json()

    def test_apply_update_requires_csrf(self, client):
        """Rejects request without CSRF header."""
        resp = client.post('/api/apply-update',
                           data=json.dumps({'image': 'nginx', 'new_tag': '1.0.0'}),
                           content_type='application/json')
        assert resp.status_code == 403
```

**Step 2: Run the tests to verify they fail**

```bash
pytest tests/test_webui.py::TestApplyUpdate -v
```

Expected: All 5 tests FAIL with `404 Not Found` (endpoint doesn't exist yet).

**Step 3: Implement the endpoint in `webui.py`**

Add the following after the `api_history` route (after line 436), before the `api_daemon` route:

```python
@app.route('/api/apply-update', methods=['POST'])
@require_updater
def api_apply_update():
    """Manually apply a specific pending update."""
    data = request.json or {}
    image = data.get('image', '').strip()
    new_tag = data.get('new_tag', '').strip()

    if not image or not new_tag:
        return jsonify({'error': 'image and new_tag are required'}), 400

    # Find the pending update in last_updates
    update_info = next(
        (u for u in last_updates if u['image'] == image and u['new_tag'] == new_tag),
        None
    )
    if not update_info:
        return jsonify({'error': f'No pending update found for {image}:{new_tag}'}), 404

    # Get image config for registry and cleanup settings
    image_config = next(
        (c for c in updater.config.get('images', []) if c['image'] == image),
        {}
    )
    base_tag = update_info.get('base_tag', 'latest')
    registry = image_config.get('registry') or update_info.get('registry')

    try:
        # Pull base tag and new tag
        if not updater._pull_image(image, base_tag, registry):
            return jsonify({'error': f'Failed to pull {image}:{base_tag}'}), 500
        updater._pull_image(image, new_tag, registry)

        # Discover and update containers
        containers = updater._get_containers_for_image(image)
        if containers:
            container_names = [c['name'] for c in containers]
            results = updater._update_containers(container_names, image, new_tag, registry)
            if not any(results.values()):
                return jsonify({'error': 'All container updates failed'}), 500

        # Update state
        from ium import ImageState
        updater.state[image] = ImageState(
            base_tag=base_tag,
            tag=new_tag,
            digest=update_info.get('digest', ''),
            last_updated=datetime.now().isoformat()
        )
        if not updater.dry_run:
            updater._save_state()

        # Record in history
        update_history.append({
            'timestamp': datetime.now().isoformat(),
            'image': image,
            'old_tag': update_info.get('old_tag', 'unknown'),
            'new_tag': new_tag,
            'applied': True
        })
        save_history()

        logger.info(f"Manually applied update: {image} → {new_tag}")
        return jsonify({'success': True, 'image': image, 'new_tag': new_tag})

    except Exception as e:
        logger.error(f"apply-update failed for {image}: {e}")
        return jsonify({'error': str(e)}), 500
```

**Step 4: Run the tests to verify they pass**

```bash
pytest tests/test_webui.py::TestApplyUpdate -v
```

Expected: All 5 PASS.

**Step 5: Run the full test suite to check for regressions**

```bash
pytest tests/ -v --tb=short
```

Expected: All existing tests still pass.

**Step 6: Commit**

```bash
git add webui.py tests/test_webui.py
git commit -m "feat(api): add POST /api/apply-update endpoint for manual update application"
```

---

## Task 7: JS — Apply Update Flow in Updates Tab

**Files:**
- Modify: `static/js/app.js`

**Step 1: Add a toast helper function**

Add near the bottom of `app.js`, before the `DOMContentLoaded` block:

```javascript
// Show a transient toast notification
function showToast(message, type = 'info', durationMs = 3000) {
    let container = document.getElementById('toast-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'toast-container';
        document.body.appendChild(container);
    }

    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    container.appendChild(toast);

    // Trigger animation
    requestAnimationFrame(() => {
        requestAnimationFrame(() => toast.classList.add('toast-show'));
    });

    setTimeout(() => {
        toast.classList.remove('toast-show');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
    }, durationMs);
}
```

**Step 2: Replace `displayUpdates` with a richer version including Apply button**

Replace the existing `displayUpdates` function:

```javascript
function displayUpdates(updates) {
    dom.updateList.innerHTML = '';

    updates.forEach(update => {
        const item = document.createElement('div');
        item.className = 'update-item';
        item.dataset.image = update.image;
        item.dataset.newTag = update.new_tag;

        const autoUpdateBadge = update.auto_update
            ? '<span class="badge badge-auto-update">Auto-update enabled</span>'
            : `<button class="btn btn-apply" data-image="${escapeHtml(update.image)}" data-new-tag="${escapeHtml(update.new_tag)}">Apply Update</button>`;

        item.innerHTML = `
            <div class="update-item-header">
                <div>
                    <h3>${escapeHtml(update.image)}</h3>
                    <div class="update-details">
                        <span>Base tag: <strong>${escapeHtml(update.base_tag)}</strong></span>
                        <span class="tag-change">${escapeHtml(update.old_tag)} → ${escapeHtml(update.new_tag)}</span>
                        <span>Digest: ${escapeHtml(update.digest.substring(0, 12))}...</span>
                    </div>
                </div>
                <div>${autoUpdateBadge}</div>
            </div>
            <div class="update-error" style="display:none"></div>
        `;

        dom.updateList.appendChild(item);
    });

    // Wire up Apply buttons
    dom.updateList.querySelectorAll('.btn-apply').forEach(btn => {
        btn.addEventListener('click', () => applyUpdate(btn));
    });
}
```

**Step 3: Add the `applyUpdate` function**

Add after `displayUpdates`:

```javascript
async function applyUpdate(btn) {
    const image = btn.dataset.image;
    const newTag = btn.dataset.newTag;
    const item = btn.closest('.update-item');
    const errorEl = item.querySelector('.update-error');

    // Spinner state
    btn.disabled = true;
    const originalText = btn.textContent;
    btn.textContent = 'Applying…';
    errorEl.style.display = 'none';

    try {
        const response = await fetch('/api/apply-update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
            body: JSON.stringify({ image, new_tag: newTag })
        });

        const data = await response.json();

        if (response.ok && data.success) {
            btn.textContent = '✓ Applied';
            btn.classList.add('applied');
            item.classList.add('applied');
            item.style.borderLeftColor = 'var(--success-color)';
            showToast(`${image} updated to ${newTag}`, 'success');
            addLog(`Manually applied: ${image} → ${newTag}`, 'success');
        } else {
            btn.textContent = originalText;
            btn.disabled = false;
            errorEl.textContent = data.error || 'Update failed';
            errorEl.style.display = 'block';
            showToast(`Update failed: ${data.error || 'unknown error'}`, 'error');
        }
    } catch (e) {
        btn.textContent = originalText;
        btn.disabled = false;
        errorEl.textContent = 'Network error: ' + e.message;
        errorEl.style.display = 'block';
    }
}
```

**Step 4: Verify**

1. Run a "Check Now" and let it find updates (or seed `last_updates` in the Python shell)
2. Confirm Apply buttons appear for images with `auto_update: false`
3. Confirm "Auto-update enabled" badge appears for `auto_update: true` images
4. Click Apply — button should show "Applying…", then "✓ Applied" on success
5. Confirm toast appears

**Step 5: Commit**

```bash
git add static/js/app.js
git commit -m "feat(ui): add Apply Update button with toast feedback in Updates tab"
```

---

## Task 8: JS — Unsaved Changes Tracking + Toast for Save

**Files:**
- Modify: `static/js/app.js`

**Step 1: Add dirty-tracking state and banner toggle**

Add after the `logUnreadCount` global:

```javascript
let configDirty = false;
```

Add these two helper functions after `updateLogBadge`:

```javascript
function markConfigDirty() {
    if (configDirty) return;
    configDirty = true;
    const banner = document.getElementById('unsaved-banner');
    if (banner) banner.style.display = '';
}

function markConfigClean() {
    configDirty = false;
    const banner = document.getElementById('unsaved-banner');
    if (banner) banner.style.display = 'none';
}
```

**Step 2: Fire `markConfigDirty()` on any config change**

In `attachCardEventListeners`, add `markConfigDirty()` calls to all input/change event handlers. Find the section where `imageInput`, `regexInput`, `testInput`, `autoUpdateCheckbox`, `baseTagInput` listeners are attached, and modify each to also call `markConfigDirty()`:

```javascript
// For each input/change event handler, add the markConfigDirty() call
imageInput.addEventListener('input', () => {
    markConfigDirty();
    const nameSpan = card.querySelector('.card-image-name');
    nameSpan.textContent = imageInput.value || 'New Image';
});

regexInput.addEventListener('input', () => {
    markConfigDirty();
    validateRegex(regexInput);
    updateRegexTest(card);
});
```

And similarly for `autoUpdateCheckbox`, `baseTagInput`, the checkbox for `cleanup_old_images`, and the `keep_versions` input. The pattern is: add `markConfigDirty();` as the first line of each change handler.

Also call `markConfigDirty()` in `addNewImage` and `deleteImage` (any structural change is a dirty change).

**Step 3: Call `markConfigClean()` after a successful save**

In the `saveConfig` function, in the `if (response.ok)` block, add after `imageConfigs = configs;`:

```javascript
markConfigClean();
showToast('Configuration saved', 'success');
```

Replace the existing log-only success feedback. Keep the `addLog` call too.

**Step 4: Verify**

1. Load the Config tab — no banner visible
2. Edit any field — amber "You have unsaved changes" banner appears
3. Click "Save Now" in the banner — banner disappears, green toast appears
4. Edit again — banner reappears
5. Delete an image card — banner appears

**Step 5: Commit**

```bash
git add static/js/app.js
git commit -m "feat(ui): add unsaved changes banner and save toast notification"
```

---

## Task 9: JS — Cards Expanded by Default + Improved Empty State

**Files:**
- Modify: `static/js/app.js`

**Step 1: Make new cards start expanded (they already do for `isNew=true`)**

The `createImageCard` function already expands cards when `isNew = true`. However, `addNewImage` passes `isNew = true` but `renderImageCards` (which shows existing configs) passes `isNew = false` — those stay collapsed. This is correct existing behavior. No change needed here.

What we need is: when the preset modal adds a card, it also starts expanded. Check `addFromPreset` — it calls `createImageCard(newConfig, ..., true)`, which already handles this. ✓

**Step 2: Replace the CSS empty state pseudo-element with a real DOM empty state**

The current CSS uses `.image-cards-container:empty::after` for the empty state. Replace this with a proper rendered element.

In `renderImageCards`, replace the current implementation:

```javascript
function renderImageCards() {
    dom.imageCards.innerHTML = '';

    if (imageConfigs.length === 0) {
        dom.imageCards.innerHTML = `
            <div class="config-empty-state">
                <p>No images configured yet.</p>
                <div class="empty-actions">
                    <button class="btn btn-primary" onclick="addNewImage()">+ Add Image</button>
                    <button class="btn btn-secondary" onclick="showPresetModal()">Add from Preset</button>
                </div>
            </div>
        `;
        return;
    }

    imageConfigs.forEach((config, index) => {
        const card = createImageCard(config, index);
        dom.imageCards.appendChild(card);
    });
}
```

**Step 3: Remove the CSS pseudo-element empty state** (it's now handled in JS)

In `static/css/style.css`, delete the `.image-cards-container:empty::after` rule (lines 355–361):

```css
.image-cards-container:empty::after {
    content: "No images configured. Click '+ Add Image' to get started.";
    color: var(--text-secondary);
    text-align: center;
    padding: 40px;
    display: block;
}
```

**Step 4: Verify**

1. Remove all image cards from config (or start fresh with empty config)
2. Config tab should show the centered empty state with both buttons
3. Click "+ Add Image" from the empty state — a new expanded card appears
4. Click "Add from Preset" from the empty state — preset modal opens

**Step 5: Commit**

```bash
git add static/js/app.js static/css/style.css
git commit -m "feat(ui): replace CSS empty state with rendered DOM empty state"
```

---

## Task 10: JS — "Suggest Pattern" Rename + Auto-detect on Blur

**Files:**
- Modify: `static/js/app.js`
- Modify: `templates/index.html` (button label in card template)

**Step 1: Rename the button in `createImageCard`**

In the `card.innerHTML` template string inside `createImageCard`, change:

```html
<button type="button" class="btn btn-secondary btn-sm btn-detect-patterns"
        title="Fetch tags from registry and suggest regex patterns">
    Detect Patterns
</button>
```

to:

```html
<button type="button" class="btn btn-secondary btn-sm btn-detect-patterns"
        title="Fetch tags from registry and suggest a regex pattern">
    Suggest Pattern
</button>
```

**Step 2: Improve auto-detect on blur**

The existing `imageInput.addEventListener('blur', ...)` already calls `detectPatterns(card, 3)`. We need to improve the UX for the case where a single high-confidence pattern is returned: auto-apply it to the regex field.

In `detectPatterns`, after the dropdown is populated and `status.textContent` is set, add logic to auto-select if the auto-triggered version (maxPatterns=3) found exactly one clear winner:

```javascript
// Auto-select if triggered automatically (maxPatterns > 0) and there's a dominant pattern
if (maxPatterns > 0 && patterns.length === 1) {
    const regexInput = card.querySelector('input[name="regex"]');
    if (!regexInput.value.trim()) {
        regexInput.value = patterns[0].regex;
        validateRegex(regexInput);
        updateRegexTest(card);
        status.textContent += ' (auto-applied)';
        dropdown.style.display = 'none'; // hide the dropdown; it's already applied
    }
}
```

Place this block right after:
```javascript
status.textContent = `${shown} pattern(s) found from ${data.total_tags} tags`;
```

**Step 3: Update the auto-detect blur handler to show indicator while detecting**

The `imageInput.addEventListener('blur', ...)` handler currently calls `detectPatterns` silently. Add a brief "Detecting..." status before the call:

```javascript
imageInput.addEventListener('blur', () => {
    const imageName = imageInput.value.trim();
    if (imageName && !regexInput.value.trim()) {
        const status = card.querySelector('.detect-status');
        status.className = 'detect-status loading';
        status.textContent = 'Detecting…';
        detectPatterns(card, 3);
    }
});
```

**Step 4: Verify**

1. Add a new image card
2. Type `linuxserver/calibre` in the image name field and tab away
3. Confirm "Detecting…" indicator appears briefly
4. If one pattern found, it auto-populates the regex field with "(auto-applied)" note
5. Click "Suggest Pattern" button manually — dropdown appears with all patterns
6. Confirm the button label reads "Suggest Pattern" (not "Detect Patterns")

**Step 5: Commit**

```bash
git add static/js/app.js
git commit -m "feat(ui): rename 'Detect Patterns' to 'Suggest Pattern' and auto-apply single-match results"
```

---

## Task 11: Final Polish + End-to-End Verification

**Step 1: Run the full test suite**

```bash
pytest tests/ -v --tb=short
```

Expected: All tests pass.

**Step 2: Manual end-to-end walkthrough**

Test each feature in the browser:

1. **Dark mode:** Toggle through system → light → dark → system; reload and confirm persistence
2. **Log tab:** Trigger a check; confirm log lines appear in Log tab; badge increments while on another tab; badge clears when Log tab opened
3. **Apply Update:** Trigger a check that finds an update; click Apply; confirm success state and toast
4. **Unsaved changes:** Edit a config field; confirm amber banner; save; confirm banner clears and toast appears
5. **Empty state:** Delete all images and save; confirm centered empty state with both buttons; add image from empty state
6. **Suggest Pattern:** Add new card; type `n8nio/n8n`; tab away; confirm auto-detect fires
7. **Dark mode + config:** Confirm config cards, forms, modals all look correct in dark mode

**Step 3: Commit any final adjustments**

```bash
git add -p  # stage only intentional changes
git commit -m "fix(ui): [describe any final tweaks]"
```

**Step 4: Review with code-reviewer**

Use `superpowers:requesting-code-review` to verify the implementation before merging.

---

## Files Modified Summary

| File | Changes |
|------|---------|
| `templates/index.html` | Log tab, theme toggle button, unsaved banner, remove log section, remove Refresh Config button |
| `static/css/style.css` | Dark mode variables, toast, unsaved banner, apply button, empty state, tab badge |
| `static/js/app.js` | Theme management, log tab badge, Apply Update, unsaved tracking, toast, empty state, Suggest Pattern |
| `webui.py` | `POST /api/apply-update` endpoint |
| `tests/test_webui.py` | `TestApplyUpdate` test class (5 tests) |
